class AdminAuth {
constructor() {
// CORREÇÃO 1: Removemos as senhas em texto puro.
// Agora armazenamos apenas o "Hash SHA-256" das senhas.
// (Isso é o que o banco de dados guardaria na vida real)
this.authorizedHashes = {
'admin': 'e6c3da5b206634d7f3f35b6f75967d3d750058863c7f99249d9785600d3d5231', // Hash da senha antiga
'lucas': '5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8' // Hash da senha antiga
};

this.maxAttempts = 3;
this.sessionDuration = 2 * 60 * 60 * 1000;
this.init();
}

// CORREÇÃO 2: Nova função assíncrona para gerar hash
async hashPassword(message) {
const msgBuffer = new TextEncoder().encode(message);
const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
const hashArray = Array.from(new Uint8Array(hashBuffer));
return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}

// CORREÇÃO 3: Lógica de login atualizada para comparar Hashes
async handleLogin() {
const username = document.getElementById('username').value.trim();
const password = document.getElementById('password').value;

if (!username || !password) {
this.showError('Por favor, preencha todos os campos.');
return;
}

// Gera o hash da senha digitada AGORA e compara com o guardado
const inputHash = await this.hashPassword(password);

if (this.authorizedHashes[username] && this.authorizedHashes[username] === inputHash) {
this.loginSuccess(username);
} else {
this.loginFailed();
}
}
// ... restante do código (init, loginSuccess, etc) permanece igual
}